# Redis Local Setup and Basics (Key-Value Store)

This document provides a quick reference for setting up a local **in-memory Key-Value store (Redis)** using Docker and demonstrating core data structure operations via the CLI.

---

## 1. Local Redis Setup

Redis (Remote Dictionary Server) is an **in-memory data structure store** primarily used as a database, cache, and message broker. Data is accessed based on a unique **key** that maps to a **value**. 

### 1.1 Start the Redis Container

This command runs the official Redis server in the background, maps the default port (`6379`), and uses a Docker volume to persist data (though Redis is often used as a volatile cache).

```bash
docker run --name redis-kv-store -d -p 6379:6379 -v redis-data:/data redis
```

### 1.2 Access the Redis CLI

You must use the built-in Redis Command Line Interface (`redis-cli`) to interact with the server running inside the container.

```bash
docker exec -it redis-kv-store redis-cli
```

Once connected, the prompt will change to 127.0.0.1:6379>

## 2. Core Redis Operations (Key & String Data Type)

Redis supports various data types (Strings, Lists, Hashes, Sets, Sorted Sets), but the core **Key-Value** concept primarily uses the **String** type. All basic key operations are **O(1)** (constant time) for unmatched speed.

| Operation | Command | Example | Explanation |
| :--- | :--- | :--- | :--- |
| **Set Value** | `SET key value` | `SET user:1001 "Alice"` | Stores a value under a unique key. |
| **Get Value** | `GET key` | `GET user:1001` | Retrieves the value associated with the key. |
| **Check Exists** | `EXISTS key` | `EXISTS user:1001` | Returns `1` if the key exists, `0` otherwise. |
| **Delete Key** | `DEL key` | `DEL user:1001` | Removes the key and its associated value. |
| **Set Expiration** | `EXPIRE key seconds` | `EXPIRE session:xyz 3600` | Sets a **Time-To-Live (TTL)**, after which the key is automatically deleted (ideal for caching). |
| **Atomic Increment** | `INCR key` | `INCR page_views` | Atomically increments the numeric value of a key. Used for counters and rate-limiting. |

## 3. Key Benefits of Redis

Redis's architecture makes it indispensable for applications requiring high speed and scalability.

1.  **Extreme Speed (In-Memory):** As an **in-memory database**, all data is stored directly in RAM, resulting in microsecond-latency access times. This is ideal for caching frequently requested data.
2.  **Versatile Data Structures:** Redis is more than a simple key-value store; it natively supports complex data types (Hashes, Lists, Sets, etc.) which allow developers to implement sophisticated patterns (like leaderboards or real-time queues) directly in the database.
3.  **Horizontal Scalability:** Redis is designed to scale out easily using features like **sharding** (Redis Cluster) and **replication**, allowing it to handle massive volumes of traffic and data by distributing the load across multiple nodes.
4.  **TTL and Volatility:** The built-in **Time-To-Live (TTL)** feature and configurable **eviction policies** make it perfect for managing volatile data like user sessions, temporary tokens, and application-level caches.

## 4. Rate Limiting Example (Fixed Window Counter)

The **Fixed Window Counter** is a fundamental rate-limiting pattern that relies on the atomic `INCR` command and key expiration (`EXPIRE`). This ensures that only a fixed number of actions (e.g., 10 requests) are allowed within a specific time window (e.g., 60 seconds).

### Scenario: Limit a user to 10 requests per 60 seconds.

The key is defined by the user ID and the current time window, ensuring each user has their own counter.

| Step | Redis Command | Description |
| :--- | :--- | :--- |
| 1. **Count Request** | `INCR user:{id}:limit` | Atomically increments the counter for the specific user/window. The returned value is the new count. |
| 2. **Check Limit** | *If the count is > 10, the request is denied.* | (This logic happens in your application code). |
| 3. **Set Expiration** | `EXPIRE user:{id}:limit 60` | Sets the Time-To-Live for the counter key to 60 seconds. |

**Crucial Logic:** The `EXPIRE` command should typically only be issued if the **returned value from `INCR` in Step 1 is 1**. This guarantees the TTL is set only when the window is first created, ensuring all subsequent requests within that 60 seconds use the same window.

#### Example Commands (for `user`):

1.  **Client 1 (First Request):**
    ```
    INCR user:limit  --> Returns: 1
    EXPIRE user:limit 60  --> Sets expiration
    ```
2.  **Client 2 (Fifth Request):**
    ```
    INCR user:limit  --> Returns: 5
    ```
3.  **Client 3 (Eleventh Request - Blocked):**
    ```
    INCR user:limit  --> Returns: 11
    ```
    *The application blocks the request because 11 > 10.*

> **Note:** This method is efficient because it requires only a **single network call** to Redis to both update and retrieve the current count, ensuring **atomicity** (no race conditions) across all clients.